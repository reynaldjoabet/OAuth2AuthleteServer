package services

import scala.util.Failure
import scala.util.Success
import scala.util.Try

import cats.syntax.all.*
import cats.Monad

import com.authlete.common.dto.TokenCreateRequest
import com.authlete.common.dto.TokenCreateResponse
import com.authlete.common.dto.TokenResponse
import com.authlete.common.types.GrantType
import com.nimbusds.jwt.JWT
import com.nimbusds.jwt.JWTParser
import com.nimbusds.jwt.SignedJWT
import org.http4s.dsl.Http4sDsl
import org.http4s.Response
import org.http4s.Status

/**
  * A sample implementation of processing a token request which uses the grant type
  * {@code "urn:ietf:params:oauth:grant-type:jwt-bearer"} (<a href=
  * "https://www.rfc-editor.org/rfc/rfc7523.html">RFC 7523</a>).
  *
  * <p> The token request contains an {@code assertion} request parameter. Its value is a JWT.
  * However, RFC 7523 does not define details about how the JWT is generated by whom. As a result,
  * it is not defined in the specification how to obtain the key whereby to verify the signature of
  * the JWT. Therefore, each deployment has to define their own rules which are necessary to
  * determine the key for signature verification. </p>
  *
  * <p> Note that your system must verify the signature of the assertion JWT by itself. The JavaDoc
  * of <a href=
  * "https://authlete.github.io/authlete-java-common/com/authlete/common/dto/TokenResponse.html"
  * >TokenResponse</a> explains (1) what validation steps Authlete performs on behalf of your system
  * and (2) why Authlete does not (can not) verify the signature of the assertion JWT. </p>
  *
  * @see
  *   <a href="https://www.rfc-editor.org/rfc/rfc7521.html">RFC 7521 Assertion Framework for OAuth
  *   2.0 Client Authentication and Authorization Grants</a>
  *
  * @see
  *   <a href="https://www.rfc-editor.org/rfc/rfc7523.html">RFC 7523 JSON Web Token (JWT) Profile
  *   for OAuth 2.0 Client Authentication and Authorization Grants</a>
  */

// This sample implementation creates an access token.
object JwtAuthzGrantProcessor {

  def createResponse[F[_]: Monad](
      resp: TokenResponse,
      authleteService: AuthleteService[F]
  ): Either[Exception, F[Response[F]]] = {
    val dsl = Http4sDsl[F]
    import dsl.*

    // Client ID to assign.
    val clientId = determineClientId(resp)

    // Validate the assertion.
    val jwt = validateAssertion(resp)

    // Subject to assign.
    // val subject = determineSubject(resp)

    (determineClientId(resp), validateAssertion(resp).flatMap(jwt => determineSubject(jwt))).mapN {
      (clientId, subject) =>
        // Scopes to assign.
        val scopes = determineScopes(resp)

        // Create an access token.
        createAccessToken(clientId, scopes, subject, authleteService).flatMap { resp =>

          // The content of a successful token response that conforms to RFC 6749.
          val content = String.format(
            "{\n" +
              "  \"access_token\":\"%s\",\n" +
              "  \"token_type\":\"Bearer\",\n" +
              "  \"expires_in\":%d,\n" +
              "  \"scope\":\"%s\"\n" +
              "}\n",
            extractAccessToken(resp),
            resp.getExpiresIn(),
            resp.getScopes().mkString(" ")
          )
        // json
        Status.Ok(content)
        }
    }
  }

  private def validateAssertion(resp: TokenResponse) = {
    // The value of the 'assertion' request parameter.
    val assertion = resp.getAssertion()

    // This implementation requires that the assertion is a signed JWT.
    val jwt = parseAsSignedJwt(assertion)

    // When the assertion is a signed JWT, all validation steps common to
    // signed JWTs have been done on Authlete side except verification of
    // the signature. See the JavaDoc of TokenResponse class for details
    // about the validation steps performed on Authlete side.
    //
    //   https://authlete.github.io/authlete-java-common/com/authlete/common/dto/TokenResponse.html
    //

    // Verify the signature of the JWT.
    jwt.filterOrElse(jwt => verifySignature(jwt), new Exception("to be implemented"))

  }

  private def parseAsSignedJwt(assertion: String): Either[Exception, SignedJWT] =
    // Parse the assertion as a JWT.
    Try(JWTParser.parse(assertion))
      .toEither
      .leftMap(_ => new Exception("The assertion failed to be parsed as a JWT."))
      // If the JWT is not a signed JWT.
      .filterOrElse(
        jwt => !jwt.isInstanceOf[SignedJWT],
        new Exception("This authorization server requires that the assertion be a signed JWT")
      ).map(_.asInstanceOf[SignedJWT])

  private def verifySignature(jwt: SignedJWT): Boolean =
    // Because RFC 7523 does not define details about how the assertion
    // JWT is generated by whom. As a result, it is not defined in the
    // specification how to obtain the key whereby to verify the signature
    // of the JWT. Therefore, each deployment has to define their own rules
    // which are necessary to determine the key for signature verification.

    // Your system must define additional requirements about the assertion
    // so that your system can determine how to obtain the key for signature
    // verification.
    //
    // For example, your system may define a rule like below.
    //
    //   The value of the 'assertion' request parameter must be an ID Token
    //   issued by "https://example.com".
    //
    // If the assertion is an ID Token, it is possible to find the key for
    // signature verification by (1) getting the server configuration from
    // the discovery endpoint, (2) getting the JWK Set document from the
    // location indicated by the "jwks_uri" property in the server
    // configuration, and (3) selecting a key from among the JWK Set document.

    // TODO
    // In any case, your implementation must verify the signature of the JWT.

    true

  private def determineClientId(resp: TokenResponse) = {
    // The client ID of the client that made the token request.
    val clientId = resp.getClientId()

    // If 'Service.jwtGrantByIdentifiableClientsOnly' is false, token
    // requests that contain no client identifier are not rejected.
    // In that case, 'clientId' here becomes 0.
    //
    // However, this authorization server implementation does not allow
    // unidentifiable clients to make token requests with the grant type
    // "urn:ietf:params:oauth:grant-type:jwt-bearer" regardless of whether
    // 'Service.jwtGrantByIdentifiableClientsOnly' is true or false.
    Either.cond(
      clientId == 0,
      clientId,
      Exception(
        "This authorization server does not allow unidentifiable " +
          "clients to make token requests with the grant type " +
          "'urn:ietf:params:oauth:grant-type:jwt-bearer'."
      )
    )

    // This simple implementation uses the client ID of the client
    // that made the token request.
  }

  private def determineScopes(resp: TokenResponse) =
    // This simple implementation uses the scopes specified by the token request.
    resp.getScopes()

  private def determineSubject(jwt: SignedJWT) = {

    // Get the value of the "sub" claim from the payload of the JWT.
    //
    // RFC 7523 requires that an assertion used with the grant type
    // "urn:ietf:params:oauth:grant-type:jwt-bearer" have the "sub"
    // claim.

    Try(jwt.getJWTClaimsSet().getSubject())
      .toEither
      .leftMap(_ =>
        new Exception(
          "The value of the 'sub' claim failed to be extracted from the payload of the assertion."
        )
      )
  }

  private def createAccessToken[F[_]](
      clientId: Long,
      scopes: Array[String],
      subject: String,
      authleteService: AuthleteService[F]
  ) = {
    // A request to Authlete's /auth/token/create API.
    val request = new TokenCreateRequest()
      .setGrantType(GrantType.JWT_BEARER)
      .setClientId(clientId)
      .setScopes(scopes)
      .setSubject(subject)

    // Call Authlete's /auth/token/create API to create an access token.
    authleteService.tokenCreate(request)
    // API call to /auth/token/create failed."

  }

  private def extractAccessToken(tcResponse: TokenCreateResponse) = {
    // If a JWT access token has been issued, it takes precedence over
    // a random-string access token.

    // An access token in the JWT format. This response parameter holds
    // a non-null value when Service.accessTokenSignAlg is not null.
    val at = tcResponse.getJwtAccessToken()

    // If an access token in the JWT format has not been issued.
    val accessToken = Option(at).getOrElse(tcResponse.getAccessToken()) // An access token whose format is just a random string.

    accessToken
    // The newly issued access token.
  }

}
